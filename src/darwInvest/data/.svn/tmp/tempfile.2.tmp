package darwInvest.data;

import java.io.Serializable;
import java.util.Date;
import java.util.Set;
import java.util.TreeMap;
import java.util.Map.Entry;

/**
 * The ticker object contains the information related to a
 * single stock
 * @author Kevin Dolan, Andrew Perrault
 */
public class Ticker implements Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	private String symbol;
	private TreeMap<Long, double[]> data;
	private TreeMap<Long, NewsEvent> news;
	
	public Ticker(String symbol) {
		this.symbol = symbol;
		data = new TreeMap<Long, double[]>();
		news = new TreeMap<Long, NewsEvent>();
	}
	
	/**
	 * Add a piece of data to the ticker history
	 * @param time  the time of the data point
	 * @param point the point to be added
	 */
	public void addData(long time, double[] point) {
		data.put(time, point);
	}
	
	/**
	 * Add a piece of data to the ticker history
	 * @param date  the date object of the data point
	 * @param point the point to be added
	 */
	public void addData(Date date, double[] point) {
		long time = date.getTime();
		addData(time, point);
	}
	
	/**
	 * Adds a collection of data to the ticker history
	 * @param newdata  the new collection of data
	 */
	public void addData(TreeMap<Long, double[]> newdata) {
		data.putAll(newdata);
	}
	
	/**
	 * Add a piece of news to the ticker history
	 * @param time  the time of the data point
	 * @param story the news story object to add
	 */
	public void addNews(long time, NewsEvent story) {
		news.put(time, story);
	}
	
	/**
	 * Add a piece of news to the ticker history
	 * @param date  the date object of the data point
	 * @param story the news story object to add
	 */
	public void addNews(Date date, NewsEvent story) {
		long time = date.getTime();
		addNews(time, story);
	}
	
	/**
	 * @return the symbol of this ticker
	 */
	public String getSymbol() {
		return symbol;
	}
	
	
	/**
	 * @return the appropriate range of entries
	 */
	@SuppressWarnings("unchecked")
	private Entry<Long, ?>[] getRange(TreeMap<Long, ?> data, long time) {
		if(time > data.lastKey()) {
			Entry<Long, ?> entry = data.lastEntry();
			return new Entry[] { entry, entry };
		}
		if(time < data.firstKey()) {
			Entry<Long, ?> entry = data.firstEntry();
			return new Entry[] { entry, entry };
		}
		return new Entry[] { data.floorEntry(time), data.ceilingEntry(time) };
	}
	
	/**
	 * Determine the (potentially interpolated) price point of a given time
	 * @param time  the time to get the value for
	 * @param index the index of the price point to access
	 * @return 	 	the interpolated price value
	 */
	public double getData(long time, int index) {
		Entry<Long, ?>[] result = getRange(data, time);
		
		double[] value;
		double range;
		
		long x1 = result[0].getKey();
		value = (double[]) result[0].getValue();
		double y1 = value[index];
		
		long x2 = result[1].getKey();
		value = (double[]) result[1].getValue();
		double y2 = value[index];
		
		range = x2 - x1;
		if(range == 0)
			return y1;
		
		double position = time - x1;
		double proportion = position / range;
		
		range = y2 - y1;
		
		return proportion * range + y1;
	}
	
	/**
	 * Get a list of all news stories in a given time range, with their associated timestamps
	 * @param firstTime the beginning of the time range
	 * @param lastTime	the end of the time range
	 * @return			the set consisting of (time -> news) entries
	 */
	public Set<Entry<Long, NewsEvent>> getNews(long firstTime, long lastTime) {
		return (news.subMap(firstTime, lastTime)).entrySet();
	}
	
	/**
	 * @return the first time of this data set (considering only price information)
	 */
	public long getFirstTime() {
		return data.firstKey();
	}
	
	/**
	 * @return the last time of this data set (considering only price information)
	 */
	public long getLastTime() {
		return data.lastKey();
	}
	
}
